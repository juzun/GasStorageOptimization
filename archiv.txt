# ----------------------------------------------------------------------------
# # Binární proměnné graficky

# sum_t = np.zeros(len(index))
# for i in range(sum_t.size):
#     sum_t[i] = sum(t_wit[index[i],k] for k in withdrawal_idx)

# l_inj = m.l_inj.extract_values()
# u_inj = m.u_inj.extract_values()
# l_wit = m.l_wit.extract_values()
# u_wit = m.u_wit.extract_values()
# sum_ul = np.zeros(len(index))
# for i in range(sum_ul.size):
#     for j in withdrawal_idx:
#         if l_wit[index[i],j] == u_wit[index[i],j]:
#             sum_ul[i] = l_wit[index[i],j]
            
# fig, ax = plt.subplots(figsize=(11,4))
# ax.plot(index, sum_t, label='t', color='k', linewidth=1)
# ax.fill_between(index, 0, sum_t, color='k', alpha=0.2)
# ax.plot(index, sum_ul, label='ul', color='r', linewidth=1)
# ax.fill_between(index, 0, sum_ul, color='r', alpha=0.2)

# ax.set_xticks(ticks=x_pos, labels=x_ticks1, rotation=45, ha='right')
# ax.tick_params(color='gray', width=0.5)
# ax2 = ax.secondary_xaxis('top')
# ax2.set_xticks(ticks=x_pos, labels=x_ticks2, rotation=45, ha='left')
# ax.set_xlim([index[0], index[len(index)-1]])
# ax.axhline(y=0, color='k', linestyle='dashed')
# ax.grid(visible=True, color='gray', linestyle='dotted', linewidth=1, alpha=0.3)
# ax.legend()
# ax.set_frame_on(False)
# plt.show()



# ----------------------------------------------------------------------------
# # Graf pyplot

index = dates
x = np.array(list(x_dict.values()))
y = -np.array(list(y_dict.values()))
z = np.array(list(z_dict.values()))
op = np.empty(x.size)
for i in range(op.size):
    if x[i] == 0:
        op[i] = y[i]
    else:
        op[i] = x[i]

tab_inj = m.tab_inj.extract_values()
tab_wit = m.tab_wit.extract_values()
max_op = np.empty(x.size)
for i in range(max_op.size):
    if index[i].month >= season_inj[0] and index[i].month <= season_inj[1]:
        max_op[i] = ir_dict[index[i]]*sum(tab_inj[(j,'portion')]*t_inj[index[i],j] for j in injection_idx)
    else:
        max_op[i] = -wr_dict[index[i]]*sum(tab_wit[(k,'portion')]*t_wit[index[i],k] for k in withdrawal_idx)

x_ticks1 = [f'{prices_monthly["year"][i]}-{prices_monthly["month"][i]}' for i in prices_monthly.index]
x_ticks2 = [round(d,1) for d in prices_monthly['price']]
x_pos = [d for d in index if d.day==1]
if date_start.day != 1:
    x_pos.insert(0,date_start)

# ----------------------------------------------------------------------------

fig, ax = plt.subplots(figsize=(11,4))
ax.plot(index, max_op, label='maximum', color='orange', linewidth=1)
ax.plot(index, op, label='operations', color='green', linewidth=1)
ax.fill_between(index, 0, op, color='green', alpha=0.2)
ax.fill_between(index, op, max_op, color='orange', alpha=0.2)

ax.set_ylabel('MWh/d')
ax.set_xticks(ticks=x_pos, labels=x_ticks1, rotation=45, ha='right')
ax.tick_params(color='gray', width=0.5)
ax2 = ax.secondary_xaxis('top')
ax2.set_xticks(ticks=x_pos, labels=x_ticks2, rotation=45, ha='left')
ax.set_xlim([index[0], index[len(index)-1]])
ax.set_ylim([-35000, 35000])
ax.axhline(y=0, color='k', linestyle='dashed')
ax.grid(visible=True, color='gray', linestyle='dotted', linewidth=1, alpha=0.3)
ax.legend()
ax.set_frame_on(False)
plt.show()

# ----------------------------------------------------------------------------

fig, ax = plt.subplots(figsize=(11,4))
ax.plot(index, z, label='storage', color='blue', linewidth=1)
ax.fill_between(index, 0, z, color='blue', alpha=0.2)

ax.set_ylabel('MWh')
ax.set_xticks(ticks=x_pos, labels=x_ticks1, rotation=45, ha='right')
ax.tick_params(color='gray', width=0.5)
ax2 = ax.secondary_xaxis('top')
ax2.set_xticks(ticks=x_pos, labels=x_ticks2, rotation=45, ha='left')
ax.set_xlim([index[0], index[len(index)-1]])
ax.set_ylim([-z.max()*0.1, z.max()*1.1])
ax.axhline(y=0, color='k', linestyle='dashed')
ax.grid(visible=True, color='gray', linestyle='dotted', linewidth=1, alpha=0.3)
ax.legend()
ax.set_frame_on(False)
ax.ticklabel_format(axis='y', style='plain')
plt.show()

# ----------------------------------------------------------------------------
# # Save/load vars

# vars_to_save = {'x':x_dict,'y':y_dict,'z':z_dict,'t_inj':t_inj,'l_inj':l_inj,'u_inj':u_inj,'t_wit':t_wit,'l_wit':l_wit,'u_wit':u_wit,'ir':ir_dict,'wr':wr_dict}
# for key, val in vars_to_save.items():
#     with open(f'{key}.pickle', 'wb') as handle:
#         pickle.dump(val, handle, protocol=pickle.HIGHEST_PROTOCOL)

# loaded_vars = {}
# keys_to_load = ['x','y','z','t_inj','l_inj','u_inj','t_wit','l_wit','u_wit','ir','wr']
# for key in keys_to_load:
#     with open(f'{key}.pickle', 'rb') as handle:
#         loaded_vars[key] = pickle.load(handle)
    
# x_dict = loaded_vars['x']
# y_dict = loaded_vars['y']
# z_dict = loaded_vars['z']
# t_inj = loaded_vars['t_inj']
# l_inj = loaded_vars['l_inj']
# u_inj = loaded_vars['u_inj']
# t_wit = loaded_vars['t_wit']
# l_wit = loaded_vars['l_wit']
# u_wit = loaded_vars['u_wit']
# ir_dict = loaded_vars['ir']
# wr_dict = loaded_vars['wr']


# ----------------------------------------------------------------------------
# # Old params

# tab_inj = np.array([[0,8,16,48,75,82,91,96],
#                     [8,16,48,75,82,91,96,100],
#                     [50,75,100,93,80,65,55,20]])/100
# tab_wit = np.array([[0,3,15,35,72,85],
#                     [3,15,35,72,85,100],
#                     [18,53,78,100,73,40]])/100
# inj_dict = {(injection_idx[j],tab_val[l]): tab_inj[l,j] for j in range(n_inj) for l in range(3)}
# wit_dict = {(withdrawal_idx[k],tab_val[l]): tab_wit[l,k] for k in range(n_wit) for l in range(3)}


# ----------------------------------------------------------------------------
# # BSD stuff

# for bsd, we use different curve
bsd_wit_curve = np.array([[0,3,15,35,72,85],
                          [3,15,35,72,85,100],
                          [18,53,78,100,100,100]])/100

# BSD SY 23/24
bsd_wr = {dt.date(2023,10,1):15099.8,dt.date(2023,11,1):26424.7,dt.date(2023,12,1):33974.6,dt.date(2024,1,1):37749.6,dt.date(2024,2,1):33974.6,dt.date(2024,3,1):26424.7}
bsd_wgv = {dt.date(2023,10,1):379337.1,dt.date(2023,11,1):663839.9,dt.date(2023,12,1):853508.5,dt.date(2024,1,1):948342.7,dt.date(2024,2,1):853508.5,dt.date(2024,3,1):663839.9}

bsd_months2 = [list(bsd_wgv.keys())[i].month for i in range(0,len(bsd_wgv))]
m.bsd_months2 = pyo.Set(initialize=)

# bsd_wit_dict_days={}
# for j in range(n_wit):
#     for l in range(3):
#         bsd_wit_dict_days[withdrawal_idx[j],tab_val[l]] = bsd_wit_dict[l,j]            

# bsd_wr_days = {}
# for i in dates:
#     bsd_wr_days[i] = 0
#     for d in bsd_wr.keys():
#         if d <= i and d.month == i.month and d.year == i.year:
#             bsd_wr_days[i] = bsd_wr[d]
# bsd_wgv_days = {}
# for i in dates:
#     bsd_wgv_days[i] = 0
#     for d in bsd_wgv.keys():
#         if d <= i and d.month == i.month and d.year == i.year:
#             bsd_wgv_days[i] = bsd_wgv[d]

# m.bsd_tab_wit = pyo.Param(m.k, m.tab_val, initialize=bsd_wit_dict_days)
# m.bsd_wr = pyo.Param(m.i, initialize=bsd_wr_days)
# m.bsd_wgv = pyo.Param(m.i, initialize=bsd_wgv_days)

# # Constraints:

# if check_bsd:
#     m.constr_bsd_wr = pyo.ConstraintList()
#     for i in m.i:
#         m.constr_bsd_wr.add(0.3*m.bsd_wr[i] <= (m.wr[i]+m.mnd_wr[i])*sum(m.bsd_tab_wit[(k,'portion')]*m.t_wit[i,k] for k in m.k))

#     m.constr_bsd_wgv = pyo.ConstraintList()
#     for i in m.i:
#         if i.day == 1:
#             iter_day = i
#             mon = []
#             while iter_day.month == i.month:
#                 mon.append(iter_day)
#                 iter_day += delta
#             m.constr_bsd_wgv.add(0.3*m.bsd_wgv[i] <= sum((m.wr[j]+m.mnd_wr[i])*sum(m.bsd_tab_wit[(k,'portion')]*m.t_wit[j,k] for k in m.k) for j in mon))
#             if i == date_start:
#                 continue
#             else:
#                 m.constr_bsd_wgv.add(0.3*m.bsd_wgv[i] <= m.z[i-delta])    

# bsd_wr_dict = m.bsd_wr.extract_values()
# bsd_wgv_dict = m.bsd_wgv.extract_values()

# bsd_wr = -0.3*np.array(list(bsd_wr_dict.values()))
# bsd_wgv = 0.3*np.array(list(bsd_wgv_dict.values()))

#fig.add_trace(po.Scatter(x=index, y=bsd_wr, name='BSD WR', line_color='#bac52d', mode='lines'))




# ----------------------------------------------------------------------------
# # Classmethods

    _instances: list = []
    _dates: List[dt.date] = []
    _total_data: pd.DataFrame = None
    _total_operations: Dict[dt.date, float] = {}
    _total_max_operations: Dict[dt.date, float] = {}
    _total_gs_state: Dict[dt.date, float] = {}
    _total_wgv: Dict[dt.date, float] = {}

    def __init__(self, name: str, date_start: dt.date, date_end: dt.date) -> None:
        GasStorage._instances.append(self)

    @classmethod
    def collect_all_storages(cls) -> None:
        if not cls._instances:
            raise Exception('No objects initialized yet.')
        for self in cls._instances:
            if not self.solved:
                raise Exception("One of the objects wasn't solved yet")
        date_min = min(cls._instances[0].dates)
        date_max = max(cls._instances[0].dates)
        for self in cls._instances:
            if min(self.dates) < date_min:
                date_min = min(self.dates)
            if max(self.dates) > date_max:
                date_max = max(self.dates)

        cls._dates = [date_min + dt.timedelta(days=i) for i in range(0,(date_max-date_min).days+1)]
        cls._total_operations = {key: 0 for key in cls._dates}
        cls._total_max_operations = {key: 0 for key in cls._dates}
        cls._total_gs_state = {key: 0 for key in cls._dates}
        cls._total_wgv = {key: 0 for key in cls._dates}
        for self in cls._instances:
            wgv_dict = self.get_dict_from_column('wgv')
            for d in cls._dates:
                if d in self.res_operations.keys():
                    cls._total_operations[d] += self.res_operations[d]
                if d in self.max_operations.keys():
                    cls._total_max_operations[d] += self.max_operations[d]
                if d in self.res_gs_state.keys():
                    cls._total_gs_state[d] += self.res_gs_state[d]
                if d in wgv_dict.keys():
                    cls._total_wgv[d] += wgv_dict[d]
        cls._total_data = pd.DataFrame(
            list(zip(
                list(cls._total_operations.values()),list(cls._total_gs_state.values()),
                list(cls._total_max_operations.values()),list(cls._total_wgv.values()))),
            index=pd.DatetimeIndex(cls._dates),
            columns=['W/I','Stav','Max C', 'WGV'])
        cls._total_data['yyyy-mm-dd'] = cls._total_data.index.date
        cls._total_data['Rok'] = cls._total_data.index.year
        cls._total_data['M'] = cls._total_data.index.month
        cls._total_data['Stav %'] = cls._total_data['Stav']/cls._total_data['WGV']

        cls._total_daily_export = pd.DataFrame(
            cls._total_data[['Rok','M','W/I','Stav', 'Stav %','Max C', 'WGV']],
            index=cls._dates)
        total_daily_export_agg = cls._total_daily_export.groupby(['Rok','M']).agg(
            w_i=('W/I','sum'), year=('Rok', 'min'), month=('M', 'min'), wgv=('WGV', 'min')
        )
        for self in cls._instances:
            cls._total_daily_export[f'Stav {self.name}'] = self.daily_export['Stav']
            cls._total_daily_export[f'W/I {self.name}'] = self.daily_export['W/I']
            cls._total_daily_export[f'Max C {self.name}'] = self.daily_export['Max C']

        gs_state_monthly = []
        z0 = 0
        for self in cls._instances:
            if min(self.dates) == min(cls._dates):
                z0 += self.z0
        for i, val in enumerate(total_daily_export_agg.w_i.values):
            if i == 0:
                gs_state_monthly.append(z0 + val)
                continue
            gs_state_monthly.append(gs_state_monthly[i-1] + val)

        cls._total_monthly_export = pd.DataFrame(    
            list(zip(
                total_daily_export_agg.year.values, total_daily_export_agg.month.values, 
                total_daily_export_agg.w_i.values, gs_state_monthly, total_daily_export_agg.wgv
            )),
            columns=['Rok','M','W/I','Stav','WGV']
        )
        cls._total_monthly_export['Stav %'] = cls._total_monthly_export['Stav']/cls._total_monthly_export['WGV']

        cls._total_monthly_export = cls._total_monthly_export[['Rok','M','W/I','Stav','Stav %']]
        cls._total_daily_export = cls._total_daily_export[
            ['Rok','M','W/I',*[f'W/I {self.name}' for self in cls._instances],'Stav','Stav %',*[f'Stav {self.name}' for self in cls._instances],
                'Max C',*[f'Max C {self.name}' for self in cls._instances]]
        ]

    @classmethod
    def create_total_graph(cls):
        cls._fig = po.Figure()
        cls._fig.add_trace(po.Scatter(x=cls._dates, y=list(cls._total_max_operations.values()), name='Max. operations', line_color='#ffa600', mode='lines'))
        cls._fig.add_trace(po.Scatter(x=cls._dates, y=list(cls._total_operations.values()), name='Operations', fill='tozeroy', line_color='#74d576', mode='lines'))
        cls._fig.add_trace(po.Scatter(x=cls._dates, y=list(cls._total_gs_state.values()), name='GS state', fill='tozeroy', line_color='#34dbeb', yaxis = 'y2'))
        cls._fig.update_layout(
            title = f'Total gas storage optimization',
            xaxis_title = 'Date',
            yaxis = dict(
                title = 'Operations [MWh/day]'),
            yaxis2 = dict(
                title = "GS state [MWh]",
                side = 'right',
                overlaying = 'y',
                titlefont = dict(color='#34dbeb'),
                tickfont = dict(color='#34dbeb')),
            legend = dict(
                orientation = "v",
                x = 1.06,
                xanchor = 'left',
                y = 1)
        )
        cls._fig.update_xaxes(fixedrange=False)
        cls._fig.update_yaxes(zeroline=True, zerolinewidth=3, zerolinecolor='grey')